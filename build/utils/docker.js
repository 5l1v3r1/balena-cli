// Generated by CoffeeScript 1.12.5
var generateConnectOpts, tarDirectory;

exports.appendOptions = function(opts) {
  return opts.concat([
    {
      signature: 'docker',
      parameter: 'docker',
      description: 'Path to a local docker socket',
      alias: 'P'
    }, {
      signature: 'dockerHost',
      parameter: 'dockerHost',
      description: 'The address of the host containing the docker daemon',
      alias: 'h'
    }, {
      signature: 'dockerPort',
      parameter: 'dockerPort',
      description: 'The port on which the host docker daemon is listening',
      alias: 'p'
    }, {
      signature: 'ca',
      parameter: 'ca',
      description: 'Docker host TLS certificate authority file'
    }, {
      signature: 'cert',
      parameter: 'cert',
      description: 'Docker host TLS certificate file'
    }, {
      signature: 'key',
      parameter: 'key',
      description: 'Docker host TLS key file'
    }, {
      signature: 'tag',
      parameter: 'tag',
      description: 'The alias to the generated image',
      alias: 't'
    }, {
      signature: 'nocache',
      description: "Don't use docker layer caching when building",
      boolean: true
    }
  ]);
};

exports.generateConnectOpts = generateConnectOpts = function(opts) {
  var connectOpts;
  connectOpts = {};
  if ((opts.docker != null) && (opts.dockerHost == null)) {
    connectOpts.socketPath = opts.docker;
  } else if ((opts.dockerHost != null) && (opts.docker == null)) {
    connectOpts.host = opts.dockerHost;
    connectOpts.port = opts.dockerPort || 2376;
  } else if ((opts.docker != null) && (opts.dockerHost != null)) {
    throw new Error("Both a local docker socket and docker host have been provided. Don't know how to continue.");
  } else {
    connectOpts.socketPath = '/var/run/docker.sock';
  }
  if ((opts.ca != null) || (opts.cert != null) || (opts.key != null)) {
    if (!((opts.ca != null) && (opts.cert != null) && (opts.key != null))) {
      throw new Error('You must provide a CA, certificate and key in order to use TLS');
    }
    connectOpts.ca = opts.ca;
    connectOpts.cert = opts.cert;
    connectOpts.key = opts.key;
  }
  return connectOpts;
};

exports.tarDirectory = tarDirectory = function(dir) {
  var Promise, fs, getFiles, klaw, pack, path, streamToPromise, tar;
  Promise = require('bluebird');
  tar = require('tar-stream');
  klaw = require('klaw');
  path = require('path');
  fs = require('mz/fs');
  streamToPromise = require('stream-to-promise');
  getFiles = function() {
    return streamToPromise(klaw(dir)).filter(function(item) {
      return !item.stats.isDirectory();
    }).map(function(item) {
      return item.path;
    });
  };
  pack = tar.pack();
  return getFiles(dir).map(function(file) {
    var relPath;
    relPath = path.relative(path.resolve(dir), file);
    return Promise.join(relPath, fs.stat(file), fs.readFile(file), function(filename, stats, data) {
      return pack.entryAsync({
        name: filename,
        size: stats.size
      }, data);
    });
  }).then(function() {
    pack.finalize();
    return pack;
  });
};

exports.runBuild = function(params, options, getBundleInfo, logStreams) {
  var Promise, dockerBuild, doodles, es, logging, logs, resolver;
  Promise = require('bluebird');
  dockerBuild = require('resin-docker-build');
  resolver = require('resin-bundle-resolve');
  es = require('event-stream');
  doodles = require('resin-doodles');
  logging = require('../utils/logging');
  if (params.source == null) {
    params.source = '.';
  }
  logs = '';
  return tarDirectory(params.source).then(function(tarStream) {
    return new Promise(function(resolve, reject) {
      var builder, connectOpts, hooks, opts;
      hooks = {
        buildSuccess: function(image) {
          if (options.tag != null) {
            console.log("Tagging image as " + options.tag);
          }
          console.log();
          console.log(doodles.getDoodle());
          console.log();
          return resolve({
            image: image,
            log: logs
          });
        },
        buildFailure: reject,
        buildStream: function(stream) {
          var throughStream;
          getBundleInfo(options).then(function(info) {
            var arch, bundle, deviceType;
            if (info == null) {
              logging.logWarn(logStreams, 'Warning: No architecture/device type or application information provided.\n	Dockerfile/project pre-processing will not be performed.');
              return tarStream.pipe(stream);
            } else {
              arch = info[0], deviceType = info[1];
              bundle = new resolver.Bundle(tarStream, deviceType, arch);
              return resolver.resolveBundle(bundle, resolver.getDefaultResolvers()).then(function(resolved) {
                logging.logInfo(logStreams, "Building " + resolved.projectType + " project");
                return resolved.tarStream.pipe(stream);
              });
            }
          })["catch"](reject);
          throughStream = es.through(function(data) {
            logs += data.toString();
            return this.emit('data', data);
          });
          return stream.pipe(es.pipe(throughStream, logStreams.build));
        }
      };
      connectOpts = generateConnectOpts(options);
      logging.logDebug(logStreams, 'Connecting with the following options:');
      logging.logDebug(logStreams, JSON.stringify(connectOpts, null, '  '));
      builder = new dockerBuild.Builder(connectOpts);
      opts = {};
      if (options.tag != null) {
        opts['t'] = options.tag;
      }
      if (options.nocache != null) {
        opts['nocache'] = true;
      }
      return builder.createBuildStream(opts, hooks, reject);
    });
  });
};

exports.bufferImage = function(docker, imageId, tmpFile) {
  var Promise, fs, image, stream;
  Promise = require('bluebird');
  fs = require('fs');
  stream = fs.createWriteStream(tmpFile);
  image = docker.getImage(imageId);
  return image.get().then(function(img) {
    return new Promise(function(resolve, reject) {
      return img.on('error', reject).on('end', resolve).pipe(stream);
    });
  }).then(function() {
    return new Promise(function(resolve, reject) {
      return fs.createReadStream(tmpFile).on('open', function() {
        return resolve(this);
      }).on('error', reject);
    });
  });
};

exports.getDocker = function(options) {
  var Docker, Promise, connectOpts;
  Docker = require('dockerode');
  Promise = require('bluebird');
  connectOpts = generateConnectOpts(options);
  connectOpts['Promise'] = Promise;
  return new Docker(connectOpts);
};

exports.getImageSize = function(docker, image) {
  return docker.getImage(image).inspectAsync().get('Size');
};
